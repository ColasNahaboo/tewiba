#!/bin/bash
export TESTSHELL=1.1
USAGE='testshell [options] [tests...]
Runs the test suite, on all tests in the current dir (default), 
or on specific tests given as arguments.
   * Tests are given as arguments, and executed in order, they can be either
      * an executable file
      * a directory, all executable files in it will be run as tests
        Filenames beginning with a . # _ or ending with "~" are ignored
        no recursion is done, subdirs will not be explicitely scanned
     if an executable file __INIT__ is found, it will be sourced into the shell
     so that its definitions will be available for all the tests in it
     Same, if an __END__ file is found, it will be sourced after the tests
   * Nothing is printed if all tests OK. On failure, the stderr is printed
   * Tests exit code must be the number of failed tests (0 = OK)
   * A warning is printed if the test was OK but printed on stderr
   * Tests are run in their directory
   * Exit code is the number of failed tests. 
     It is also written in .testshell.res

How to write tests:
   * Tests are executable files, that exit with code 0  if OK, and the number 
     of failure if not
   * Give tests meaningful names. "Test for empty input" rather than "ei.test"
   * Filenames beginning with a "." "#" "_" or ending with "~" are ignored
     as well as files named "testshell"
   * They must print on stderr an explanation of the error, or a warning if 
     exit code is 0. Prints on stdout are only shonw in verbose mode
   * Tests can create temporary files and dirs prefixed by "$tmp."
     they will be automatically cleaned afterwards by rm -rf $tmp $tmp.*
   * Test data can be put in subdirectories, as subdirectories are not tested
   * Convenience functions & variables that you can use:
     TEST message    prints (sub)test name if verbose
     TERR message    declares an error, but continues the tests
     ERR  message    declares an error, but aborts the current test file
     TEND            terminates your test script (alias for: exit $TFAILS)
     $TV             is true in verbose mode, false otherwise
     $tmp            temporary data prefix (see above)
     $nl             is the newline character
     $TESTSHELL      the version number of testshell. 
                     Trick: put after #!/bin/bash the line:
                     [ -n "$TESTSHELL" ] || exec testshell -v "$0"
                     so that the test file can be executed standalone
     $TESTSHELLDIR   the original directory where testshell was run

Options:
   -v      verbose: prints each test name as it is run, as well as its stdout
   -x      debug: execute each test in set -x more copying also the output to
           /tmp/testshell.$LOGNAME.out Note: does not imply -v
   -s file   outputs the total number of errors in the file. 
             Default is ".testshell.errors" in current dir

Version '"$TESTSHELL"' - Web site: http://colas.nahaboo.net/Software/TestShell
Copyright (c) 2013-2015 Colas Nahaboo (http://colas.nahaboo.net)
MIT License: http://opensource.org/licenses/MIT
'

export debug=false
export debuglog=/tmp/testshell.$LOGNAME.out
export statusfile=$PWD/.testshell.errors
export TESTSHELLDIR="$PWD" TV

err () { echo "***ERROR: $*" >&2; exit 1; }
warn () { echo "###Warning: $*" >&2; }
V () { :;}; T () { :;}; TV=false; E () { echo "$@";}; En () { echo -n "$@";}
Vn () { :;}
while test "_${1#-}" != "_$1" -a "_${1//-/}" != "_";do case "$1" in
  -v) V () { echo "== $*" >&2;}; Vn () { echo -n "== $*" >&2;}; TV=true
      T () { local i;En "==";for i in $*;do En " $i="`eval E '$'$i`;done;E;};;
  -x) debug=true; rm -f $debuglog;;
  *) echo "$USAGE"; exit 1;
esac;shift; done; if test "_$1" = "_--";then shift; fi

export ts_failures=0
export tmp=/tmp/testshell.$$
ttmp=/tmp/testshell-main.$$
export nl=$'\n' #'
export TFAILS=0
export TDIR=
TEST () { $TV && echo "== $*"; }
TERR () { echo "***TEST ERROR ${0##*/}*** $*" >&2; let fails++; }
ERR () { echo "***FATAL ERROR ${0##*/}*** $*" >&2; let fails++; exit $TFAILS; }
TEND () { exit $TFAILS; }
export -f TEST TERR ERR TEND

# guarded cd
err_cd () {
  cd "$1" 2>/dev/null || \
  err "testshell failed to enter test dir: "$(readlink -m "$1")
}

# executes all the tests that are direct sons of a dir
ts_dir () {
  local i oldpwd="$PWD"
  err_cd "$1" 
  for i in *; do
    [[ $i =~ (^[#._]|~$) ]] || [ ! -x "$i" -o -d "$i" ] ||
      [ "$i" = testshell ] && continue
    ts_test "$i"
  done
  cd "$oldpwd"
}

# execute a test in its directory
ts_test_path () {
    local path=$(readlink -m "$1") oldpwd="$PWD"
    err_cd "${path%/*}"
    ts_test "${path##*/}"
    cd "$oldpwd"
}
    
ts_init () {
  local tdir=$(/bin/pwd)
  if [ "$tdir" != "$TDIR" ]; then
    ts_end
    [ -x __INIT__ ] && source __INIT__
    TDIR="$tdir"
  fi
}

ts_end () {
  [ -n "$TDIR" ] && [ -x "$TDIR"/__END__ ] && { 
    local TODIR="$PWD"; cd "$TDIR"; source __END__; cd "$TODIR"
  }
}

# execute a test in the current directory
ts_test () {
  local t="$1"
  ts_init
  TFAILS=0
  if $debug; then
    echo "#################################################################
###################### Test: $t:
#################################################################" >>$debuglog
    bash -x "$t" 2>>$debuglog; status=$?
  else
     Vn "Test: $t:"
    ./"$t" >$ttmp.out 2>$ttmp.err; status=$?
    let 'ts_failures += status'
    if [ $status = 0 ]; then
      if test -s $ttmp.err; then 
	if $TV; then echo "OK, but printed on stderr:"
	else echo "###Warning: test $t OK, but printed on stderr:"
	fi
	print_indent $ttmp.err
      else
	$TV && echo " OK"
      fi
    else
      if $TV; then echo "***ERRORS:$status"
      else echo "***FAILED ($status ERRORS): $t"
      fi
      if test -s $ttmp.err; then print_indent $ttmp.err; fi
    fi
    if $TV && test -s $ttmp.out; then print_indent $ttmp.out; fi
    rm -rf $tmp $tmp.*
  fi
}

# print test outputs indented by 3 spaces for lisibility
print_indent () { sed -e 's/^/   /' <"$1"; }

####################################################################### Main
# run all tests given in argument, or in the dir
if [ $# == 0 ]; then ts_dir .
else
  for t in "$@"; do
    if [  -d "$t" ]; then ts_dir "$t"
    elif [ -x "$t" ]; then 
      if [[ $t =~ / ]]; then ts_test_path "$t"
      else ts_test "$t"
      fi
    else err "$t is not a test!"
    fi
  done
fi
ts_end

# cleanup temp files
rm -rf $ttmp $ttmp.* $tmp $tmp.*

# print global tests results
if [ $ts_failures = 0 ]; then V "All tests OK =="
else echo "== ***** Total tests failed: $ts_failures *****"
fi
$debug && echo "== log of execution in $debuglog"
[ -n "$statusfile" ] && echo "$ts_failures" >"$statusfile"
exit $ts_failures
