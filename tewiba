#!/bin/bash
export TEWIBA=1.4.3
USAGE='tewiba [options] [tests...]
Tewiba: TEst WIth BAsh: a simple test suite, in the spirit of shell scripting
Runs the test suite, on all tests in the current dir (default), 
or on specific tests or directories of tests given as arguments.
   * Tests are given as arguments, and executed in order, they can be either
      * an executable file
      * a directory, all executable files in it will be run as tests
        Filenames beginning with a . # _ or ending with "~" are ignored
        no recursion is done, subdirs will not be explicitely scanned
        except the ones ending in .subtests wthat will be also run
     If an executable file __INIT__ is found, it will be sourced into the shell
     (read) so that its definitions will be available for all the tests in it
     Same, if an __END__ file is found, it will be sourced after the tests
   * Nothing is printed if all tests OK. On failure, the stderr is printed
   * Tests exit code must be the number of failed tests (0 means OK)
   * A warning is shown if the test was OK but printed on stderr
   * Tests are run in their directory
   * Tewiba exit code is the total number of failed tests. 

How to write tests:
   * Tests are executable files (in any language), that exit with code 0 if OK,
     and the number of failures if not
   * Test file names can be meaningful, e.g: "Test for empty input"
   * Filenames beginning with a "." "#" "_" or ending with "~" are ignored
     as well as files named "tewiba"
   * They must print on stderr an explanation of the error, or a warning if 
     exit code is 0. Prints on stdout are only shonw in verbose mode
   * Tests can create temporary files and dirs prefixed by "$tmp."
     they will be automatically cleaned afterwards by rm -rf $tmp $tmp.*
   * Test data can be put in subdirectories, as subdirectories are not tested
   * Convenience functions & variables that you can use in bash script tests:
     TLEVEL chars  only runs if a level in chars is in the ones given by -l,
                   or -l not specified. Each level is an alphanumeric char.
     TLEVEL_ONLY chars    Same as above but does not run if -l not given 
     TEST message  prints sub-test (the file name is the test name) name if 
                   verbose, and as label in TERR messages
     TERR message  declares an error, but continues the tests
     FERR message  fatal error: also aborts the current test file
     TEND          MANDATORY: terminates your test script.
                   (an alias for: exit $TFAILS)
                   This is the only function really mandatory in a test file.
     TINIT id...   For each id (composed of letters, numbers, and _ - .)
                   ensures that files __INIT__id and __END__id are sourced,
                   if they exist, before and after all tests of the dir,
                   after and before __INIT__ and __END__ respectively
     DOTEST [-o|-e|-s] label expected-output-string parameters
                   runs the command in $TOTEST - that you must define - with
                   the parameters as its command line options, compare its
                   output to the expected-output-string (or its stderr with
                   -e, or its exit code status with -s. The default is -o for
                   stdout), and in case of difference triggers a TERR 
                   displaying the label, the result and the expected string.
     $TV           is true in tewiba verbose mode, false otherwise
     $tmp          temporary data prefix (see above)
     $nl           is the newline character
     $TEWIBA       the version number of tewiba. Uses semantic versioning.
                   Trick: put after #!/bin/bash the line:
                   [ -n "$TEWIBA" ] || exec tewiba -v "$0"
                   so that the test file can be executed standalone as it will
                   auto-run tewiba on itself, in verbose mode.
     $TEWIBADIR    the original directory where tewiba was run
   * All tewiba functions above print on stderr.
   * IMPORTANT: the shell function TCLEANUP must be called at the end of the
     tests, to clean the temporary data. tewiba traps the signal 0 for this.
     if you redefine trap 0 in your tests, or in a script you source, you 
     should either make your trap function also call TCLEANUP, or redo a
     "trap TCLEANUP 0" at the end of your tests.

Options:
   -v      verbose: prints each test name as it is run, as well as its stdout
   -V      just prints tewiba version number
   -x      debug: execute each test in set -x mode copying also the output to
           /tmp/tewiba.$LOGNAME.out Note: does not imply -v
   -l levels  runs only tests of the levels (characters) in the string levels
           "TLEVEL x" in a test runs when given "-l y" if [y] matches x:
           thus ranges are possible: -l 0-3 matches a TLEVEL 17a
   -s      standalone: do not read __INIT__ nor __END__ files
   -e file outputs the total number of errors in the file. 
   -f      forces running tests files even without a TEND directive in them.
           Or add this line in the test file: #TNOEND
   -h      This help.

Exemple simple test file:
  #!/bin/bash
  [ -n "$TEWIBA" ] || exec tewiba -v "$0"
  TEST screen installed
  hash screen || TERR screen command not found
  TEND

Version '"$TEWIBA"' - Web site: http://colas.nahaboo.net/Software/Tewiba
Copyright (c) 2013-2020 Colas Nahaboo (http://colas.nahaboo.net)
MIT License: http://opensource.org/licenses/MIT
'

############################################ Options
export debug=false
export debuglog=/tmp/tewiba.$LOGNAME.out
export statusfile=
export ts_standalone=false
export TEWIBADIR="$PWD"
export TLEVELS=
export TV
export must_tend=true

OPTIONS='e:l:xsvV'
#----https://github.com/ColasNahaboo/bashoptions--------------getopts----v0.2.1
V(){ :;};T(){ :;};v=false;E(){ echo "$@";};En(){ E -n "$@";};VV(){ :;};nl=$'\n'
err(){ E "***ERROR: $*" >&2; exit 1;};warn(){ E "###Warning: $*" >&2;}
while getopts ":${OPTIONS}hv?" _o; do case "$_o" in
#----single letter options start-----------------------------------------
    e) statusfile="$OPTARG";;
    l) TLEVELS="$OPTARG";;
    x) debug=true; rm -f $debuglog;;
    s) ts_standalone=true;;
    f) must_tend=false;;
    V) echo "$TEWIBA"; exit 0;;
#----single letter options end-------------------------------------------
v)T(){ local i;{ En "==";for i in "$@";do [[ $i =~ [^_[:alnum:]] ]]&&En " $i"||
En " $i=${!i}";done;E;}>&2;};V(){ E "== $*" >&2;};v=true;;h) E "$USAGE"
exit;;\?)err "Bad option: -$OPTARG, -h for help.";;':')err "Missing arg: \
-$OPTARG";;*)err "Bad option: -$_o, -h for help.";esac;done;shift $((OPTIND-1))
#----bashoptions-getopts end---------------------------------------------
TV=$v
err(){ echo "***ERROR: $*" >&2; TCLEANUP; exit 1;}


############################################ Convenience funcs & vars
# These can be used in your tests script files
export tmp=/tmp/tewiba.$$
export nl=$'\n' #'
export TFAILS=0
export TOTEST
# Except the internal ones below, that start with an underscore "_"
export _ts_failures=0
export _twtmp=/tmp/tewiba-main.$$
export _TINITS=$_twtmp.tinits.
export _TEST_CURRENT
export _TDIR=

TLEVEL () { [ -z "$TLEVELS" ] || [[ $* =~ [$TLEVELS] ]] || ts_exit; }
TLEVEL_ONLY () { [[ $* =~ [$TLEVELS] ]] || ts_exit; }
TEST () { _TEST_CURRENT="$*"; $TV && echo "== $*" >&2; }
TERR () { echo "***TEST ERROR ${_TEST_CURRENT}*** $*" >&2; let TFAILS++;}
FERR () {
    echo "***FATAL ERROR ${_TEST_CURRENT}*** $*" >&2; let TFAILS++
    ts_exit $TFAILS
}
TEND () { ts_exit $TFAILS; }
TINIT () { # _TINITS is a per-dir file containing the loaded IDs
    local id="${1//[^-_.a-zA-Z0-9/}"; [ -n "$id" ] || return; 
    fgrep -qxs $id $_TINITS && return; echo $id >>$_TINITS
    [ -x __INIT__$id ] && source __INIT__$id
}
TCLEANUP () { # with guards to avoid disaster if a test undefined the vars
    [ -n "$_twtmp" ] && rm -rf $_twtmp $_twtmp.*
    [ -n "$tmp" ] && rm -rf $tmp $tmp.*
}
trap TCLEANUP 0
# low-level exit, runs TCLEANUP for safety if our trap 0 was overriden
ts_exit() { : TCLEANUP; exit "${1:-0}"; }

# Usage: DOTEST [option] label expected-output-string parameters-to-$TOTEST
# option: -e tests only the stderr of TOTEST, -s its status (exit code: $?)
# TOTEST must be defined to the command to test
DOTEST(){
    [ -n "TOTEST" ] || \
	err 'DOTEST requires $TOTEST to contain the command to test'
    local _what=o
    case "$1" in -s)_what=s;shift;; -e)_what=e;shift;; -o)_what=o;shift;; esac
    local _name="$1"; shift
    local _expect="$1"; shift
    local _result
    case $_what in
	o) _result=$($TOTEST "$@");;
	e) _result=$($TOTEST "$@" 2>&1 >/dev/null);;
	s) $TOTEST "$@" >/dev/null 2>&1; _result=$?;;
    esac
    [ "$_result" == "$_expect" ] || 
    TERR "$_name:${nl}Expect: \"$_expect\"${nl}Got>>>: \"$_result\""
}

export -f TLEVEL TEST TERR FERR TEND TINIT ts_exit TCLEANUP DOTEST

############################################ Code

# cautious cd
err_cd () {
    cd "$1" 2>/dev/null || \
	err "tewiba failed to enter test dir: "$(readlink -m "$1")
}

# executes all the tests that are direct sons of a dir
ts_dir () {
    local i oldpwd="$PWD" id
    err_cd "$1"
    export _TINITS=${_TINITS}x
    for i in *; do
	if [ -d "$i" ]; then
	    [[ $i =~ [.]subtests$ ]] && ts_dir "$i"
	else
	    [[ $i =~ (^[\#._]|~$) ]] || [ ! -x "$i" ] || [ "$i" = tewiba ] && \
		continue
	    ts_test "$i"
	fi
    done
    if [ -s $_TINITS ]; then 
	for id in $(cat $_TINITS); do
	    [ -x __END__$id ] && source __END__$id
	done
    fi
    cd "$oldpwd"
}

# go execute a test in its directory env
ts_test_path () {
    local path=$(readlink -m "$1") oldpwd="$PWD"
    err_cd "${path%/*}"
    ts_test "${path##*/}"
    cd "$oldpwd"
}

# on entering a dir, execute __INIT__
ts_init () {
    $ts_standalone && return
    local tdir=$(/bin/pwd)
    if [ "$tdir" != "$_TDIR" ]; then
	ts_end
	[ -x __INIT__ ] && source __INIT__
	_TDIR="$tdir"
    fi
}
# on leaving, execute __END__
ts_end () {
    if [ -n "$_TDIR" ] && [ -x "$_TDIR"/__END__ ]; then
	local TODIR="$PWD"; cd "$_TDIR"; source __END__; cd "$TODIR"
    fi
}

# will this test be run for the current level?
# $1=test file, returns 0 if OK
# we pre-detect it before running TLEVEL in file, avoiding extra "test ok" mess
ts_level () {
    local tlevel=$(grep -oP '^[[:space:]]*TLEVEL +\K.*' "$1")
    [ -z "$tlevel" ] && return 0 # no TLEVEL line => OK
    [ -z "$TLEVELS" ] || [[ $tlevel =~ [$TLEVELS] ]] || return 1
    return 0
}

# execute a single test in the current directory
ts_test () {
    local t="$1" s="#################################"
    ts_level "$t" || return
    ! egrep -q '^([^#]*;|[[:space:]]*)TEND([;[:space:]]|$)' "$t" && \
	$must_tend && \
	! grep -q '^ *#TNOEND' "$t" && [ -s "$t" ] && \
	err "Test file \"$t\" does not have a TEND statement. Use -f to force."
    ts_init
    _TEST_CURRENT="${t##*/}" # default TEST name: the filename
    TFAILS=0
    if $debug; then
	echo "$s$s$nl$s Test file: $t$nl$s$s" >>$debuglog
    # RUN + Trace
	bash -x "$t" >>$debuglog 2>&1; status=$?
    else
	$TV && echo -n "== Test file: $t:"
    # RUN
	./"$t" >$_twtmp.out 2> >(tee -a $_twtmp.err >&1); status=$?
	let '_ts_failures += status'
	if [ $status = 0 ]; then
	    if test -s $_twtmp.err; then 
		if $TV; then echo "OK, but printed on stderr:"
		else echo "###Warning: test $t OK, but printed on stderr:"
		fi
		print_indent $_twtmp.err
	    else
		$TV && echo " OK"
	    fi
	else
	    if $TV; then echo "***ERRORS:$status"
	    else 
		echo "***FAILED ($status ERRORS): $t"
	  if test -s $_twtmp.err; then print_indent $_twtmp.err; fi
	    fi
	fi
	if $TV && test -s $_twtmp.out; then print_indent $_twtmp.out; fi
	[ -n "$tmp" ] && rm -rf $tmp $tmp.*
    fi
}

# print test outputs indented by 3 spaces for lisibility
print_indent () { sed -e 's/^/   /' <"$1"; }

############################################ Main

# run all tests given in arguments, or in the current dir if none given
if [ $# == 0 ]; then ts_dir .
else
    for t in "$@"; do
	if [  -d "$t" ]; then ts_dir "$t"
	elif [ -x "$t" ]; then 
	    if [[ $t =~ / ]]; then ts_test_path "$t"
	    else ts_test "$t"
	    fi
	elif [ -e "$t" ]; then err "$t not found!"
	else err "$t is not executable!"
	fi
    done
fi
ts_end

############################################ Epilogue: print results, and exit
if [ $_ts_failures = 0 ]; then V "All tests OK =="
else echo "== ***** Total tests failed: $_ts_failures *****"
fi
$debug && echo "== log of execution in $debuglog"
[ -n "$statusfile" ] && echo "$_ts_failures" >"$statusfile"
ts_exit $_ts_failures
