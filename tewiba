#!/bin/bash
export TEWIBA=1.5.0-beta.2
USAGE='tewiba [options] [tests...]
Tewiba: TEst WIth BAsh: a simple test suite, in the spirit of shell scripting
Runs the test suite, on all tests in the current dir (default), 
or on specific tests or directories of tests given as arguments.
   * Tests are given as arguments, and executed in order, they can be either
      * an executable file
      * a directory, all non-empty executable files in it will be run as tests
        Files with names beginning with a . # _ or ending with "~" are ignored
        no recursion is done, subdirs will not be explicitely scanned
        except the ones ending in .subtests wthat will be also run
     If a file __INIT__ is found, it will be sourced into the shell
     (read) so that its definitions will be available for all the tests in it
     Same, if an __END__ file is found, it will be sourced after the tests
   * Nothing is printed if all tests OK. On failure, the stderr is printed
   * Tests exit code must be the number of failed tests (0 means OK)
   * A warning is shown if the test was OK but printed on stderr
   * Tests are run in their directory
   * Tewiba exit code is the total number of failed tests. 

How to write tests:
   * Tests are executable files (in any language), that exit with code 0 if OK,
     and the number of failures if not
   * Test file names can be meaningful, e.g: "Test for empty input"
   * Filenames beginning with a "." "#" "_" or ending with "~" are ignored
     as well as files named "tewiba"
   * They must print on stderr an explanation of the error, or a warning if 
     exit code is 0. Prints on stdout are only shonw in verbose mode
   * Tests can create temporary files and dirs prefixed by "$tmp."
     they will be automatically cleaned afterwards by rm -rf $tmp $tmp.*
   * Test data can be put in subdirectories, as subdirectories are not tested
   * Convenience functions & variables that you can use in bash script tests:
     TLEVEL chars  only runs if a level in chars is in the ones given by -l,
                   or -l not specified. Each level is an alphanumeric char.
     TLEVEL_ONLY chars    Same as above but does not run if -l not given 
     TEST message  prints sub-test (the file name is the test name) name if 
                   verbose, and as label in TERR messages
     TERR message  declares an error, but continues the tests
     FERR message  fatal error: also aborts the current test file
     TEND          MANDATORY: terminates your test script.
                   (an alias for: exit $TFAILS)
                   This is the only function really mandatory in a test file.
     TINIT id...   For each id (composed of letters, numbers, and _ - .)
                   ensures that files __INIT__id and __END__id are sourced,
                   if they exist, before and after all tests of the file,
                   after and before __INIT__ and __END__ respectively
     DOTEST [-o|-e|-s] label expected-output-string parameters
                   runs the command in $TOTEST - that you must define - with
                   the parameters as its command line options, compare its
                   output to the expected-output-string (or its stderr with
                   -e, or its exit code status with -s. The default is -o for
                   stdout), and in case of difference triggers a TERR 
                   displaying the label, the result and the expected string.
     $TV           is true in tewiba verbose mode, false otherwise
     $tmp          temporary data prefix (see above)
     $nl           is the newline character
     $TEWIBA       the version number of tewiba. Uses semantic versioning.
                   Trick: put after #!/bin/bash the line:
                   [ -n "$TEWIBA" ] || exec tewiba -v "$0"
                   so that the test file can be executed standalone as it will
                   auto-run tewiba on itself, in verbose mode.
     $TEWIBADIR    the original directory where tewiba was run
   * All tewiba functions above print on stderr.
   * IMPORTANT: the shell function TCLEANUP must be called at the end of the
     tests, to clean the temporary data. tewiba traps the signal 0 for this.
     if you redefine trap 0 in your tests, or in a script you source, you 
     should either make your trap function also call TCLEANUP, or redo a
     "trap TCLEANUP 0" at the end of your tests.

Options:
   -v      verbose: prints each test name as it is run, as well as its stdout
   -V      just prints tewiba version number
   -x      debug: execute each test in set -x mode copying also the output to
           /tmp/tewiba.$LOGNAME.out Note: does not imply -v
   -l levels  runs only tests of the levels (characters) in the string levels
           "TLEVEL x" in a test runs when given "-l y" if [y] matches x:
           thus ranges are possible: -l 0-3 matches a TLEVEL 17a
   -s      standalone: do not read __INIT__ nor __END__ files
   -e file outputs the total number of errors in the file. 
   -f      forces running tests files even without a TEND directive in them.
           Or add this line in the test file: #TNOEND
   -h      This help.

Exemple simple test file:
  #!/bin/bash
  [ -n "$TEWIBA" ] || exec tewiba -v "$0"
  TEST screen installed
  hash screen || TERR screen command not found
  TEND

Version '"$TEWIBA"' - Web site: http://colas.nahaboo.net/Software/Tewiba
Copyright (c) 2013-2020 Colas Nahaboo (http://colas.nahaboo.net)
MIT License: http://opensource.org/licenses/MIT
'

############################################ Options
export _debug=false
export _debuglog=/tmp/tewiba.$LOGNAME
export statusfile=
export ts_standalone=false
export TEWIBADIR=$(realpath "$PWD")
export TLEVELS=
export TV
export must_tend=true

OPTIONS='e:l:xsvV'
#----https://github.com/ColasNahaboo/bashoptions--------------getopts----v0.2.1
V(){ :;};T(){ :;};v=false;E(){ echo "$@";};En(){ E -n "$@";};VV(){ :;};nl=$'\n'
err(){ E "***ERROR: $*" >&2; exit 1;};warn(){ E "###Warning: $*" >&2;}
while getopts ":${OPTIONS}hv?" _o; do case "$_o" in
#----single letter options start-----------------------------------------
    e) statusfile="$OPTARG";;
    l) TLEVELS="$OPTARG";;
    x) _debug=true;;
    s) ts_standalone=true;;
    f) must_tend=false;;
    V) echo "$TEWIBA"; exit 0;;
#----single letter options end-------------------------------------------
v)T(){ local i;{ En "==";for i in "$@";do [[ $i =~ [^_[:alnum:]] ]]&&En " $i"||
En " $i=${!i}";done;E;}>&2;};V(){ E "== $*" >&2;};v=true;;h) E "$USAGE"
exit;;\?)err "Bad option: -$OPTARG, -h for help.";;':')err "Missing arg: \
-$OPTARG";;*)err "Bad option: -$_o, -h for help.";esac;done;shift $((OPTIND-1))
#----bashoptions-getopts end---------------------------------------------
[ -z "$TV" ] && TV=$v
err(){ echo "***ERROR: $*" >&2; TCLEANUP; exit 1;}
if $_debug; then
    for i in "$@"; do
	_debuglog="$_debuglog-${i##*/}"
    done
    _debuglog="$_debuglog.log"
    rm -f "$debuglog"
fi

############################################ Convenience funcs & vars
# These can be used in your tests script files.

# Also, these are only useful for debugging tewiba itself, 
# so they are not not mentioned in the USAGE help.
# TECHO text    An echo that prints only in verbose mode, on stderr but does
#               not pollute the stderr of tests when in sub-tewibas
# TECHOF text   Same, but prints in all modes
#
export tmp=/tmp/tewiba.$$
export nl=$'\n' #'
export TFAILS=0
export TOTEST
# Except the internal ones below, that start with an underscore "_"
export _ts_failures=0		# cumulative total of TFAILS
export _twtmp=/tmp/tewiba-main.$$ # tewiba-reserved temp zone
export _TINITS=			# the __END__$i to trigger
export _TEST_CURRENT		# last TEST arg
export _cd=			# dir we are in, with its __INIT__ executed
export _tvfd			# where TV should print for sub-tewibas

TLEVEL(){ [ -z "$TLEVELS" ] || [[ $* =~ [$TLEVELS] ]] || _ts_exit; }
TLEVEL_ONLY(){ [[ $* =~ [$TLEVELS] ]] || _ts_exit; }
TEST(){ _TEST_CURRENT="$*"; TECHO "== $*"; }
TERR(){ echo "***TEST ERROR ${_TEST_CURRENT}*** $*" >&2; let TFAILS++;}
FERR(){
    echo "***FATAL ERROR ${_TEST_CURRENT}*** $*" >&2; let TFAILS++
    _ts_exit $TFAILS
}
TEND(){ _ts_exit $TFAILS; }
TECHO(){ $TV && TECHOF "$@" || return;}
TECHOF(){ [ -n "$_tvfd" ] && echo "$@" >>$_tvfd || echo "$@" >&2;}
TINIT(){
    $ts_standalone && return
    local id; _TINITS=
    for id in "$@"; do 
	id="${id//[^-_.a-zA-Z0-9/}"
	[-z "$id" ] && continue
	[ -f __INIT__$id ] && . __INIT__$id
	_TINITS="$id $_TINITS"	# reverse order from inits
    done
    _tinits_push $_TINITS
}
TCLEANUP(){ # with guards to avoid disaster if something undefined the vars
    ts_chdir
    [ -n "$_twtmp" ] && rm -rf $_twtmp $_twtmp.*
    [ -n "$tmp" ] && rm -rf $tmp $tmp.*
}
trap TCLEANUP 0
# low-level exit, runs TCLEANUP for safety if our trap 0 was overriden
_ts_exit(){ : TCLEANUP; exit "${1:-0}"; }

# Usage: DOTEST [option] label expected-output-string parameters-to-$TOTEST
# option: -e tests only the stderr of TOTEST, -s its status (exit code: $?)
# TOTEST must be defined to the command to test
DOTEST(){
    [ -n "TOTEST" ] || \
	err 'DOTEST requires $TOTEST to contain the command to test'
    local _what=o
    case "$1" in -s)_what=s;shift;; -e)_what=e;shift;; -o)_what=o;shift;; esac
    local _name="$1"; shift
    local _expect="$1"; shift
    local _result
    case $_what in
	o) _result=$($TOTEST "$@");;
	e) _result=$($TOTEST "$@" 2>&1 >/dev/null);;
	s) $TOTEST "$@" >/dev/null 2>&1; _result=$?;;
    esac
    [ "$_result" == "$_expect" ] || 
    TERR "$_name:${nl}Expect: \"$_expect\"${nl}Got>>>: \"$_result\""
}

# push back the TINITS from the child test process to the underlying tewiba
_tinits_push(){ echo "$_cd $*" >>$_twtmp.endids;}

export -f TLEVEL TEST TERR FERR TEND TECHO TECHOF TINIT TCLEANUP DOTEST \
    _tinits_push _ts_exit

############################################ Code

# quote the arg string for regexp use, if many, prints them one per line
# $1=string, prints quoted form for inclusion in regexpes in stdout
# quotes also / for safe use in sed /.../
regexp_quote () {
  local re="$1" len=${#1} i=0 c
  while let 'i<len'; do c="${re:i:1}"; case "$c" in
      \?|\*|\||+|.|\$|\\|\[|\]|\(|\)|/) echo -n "[$c]";;
      '^') echo -n "\\^";; *) echo -n "$c";;
    esac; let i++; done
}

# _tinit_pull do not need to be exported into the test file scope.
tinits_pull(){
    local cd=$(regexp_quote "$1")
    local tinits=$(grep -oPs "^$cd \K.*" $_twtmp.endids)
    local tofix=
    [ -e $_twtmp.endids ] && tofix="$_twtmp.endids"
    [ -e $_twtmp.ends ] && tofix="$tofix $_twtmp.ends"
    [ -n "$tofix" ] && sed -r -i -e "/^$cd /d" $tofix
    echo $tinits
}

# low level cd: go into a dir, execute its __INIT__. Do not call directly
tscd(){
    local d="$1"
    [ -z "$d" ] && return
    [ "$d" == "$_cd" ] && return # nothing to do
    _cd=$(realpath "$d")
    cd "$_cd" 2>/dev/null || {
	local expansed
	[ "$_cd" != "$d" ] && expansed=" ($_cd)"
	err "Fatal: tewiba failed to enter test dir: $d$expansed"
    }	
    $ts_standalone && return
    [ -f __INIT__ ] && . __INIT__
    [ -f __END__ ] && echo "$_cd " >>$_twtmp.ends # remember to do it on exit
}

# change dir, manages exiting current dir (_cd) if non empty, and entering 
# new dir in argument in $1 if non empty. High level function.

ts_chdir(){
    local d="$1" id i
    [ "$d" == "$_cd" ] && return
    if $ts_standalone; then tscd "$d"; return; fi

    if [ -z "$d" ] || is_subdir_of "$d" "$_cd"; then # subdir, no ends
	tscd "$d"
    elif is_subdir_of "$_cd" "$d"; then # going back, ends no init
	while read i; do
	    [ "$i" == "$d" ] && break
	    is_subdir_of "$i" "$d" || break
	    cd "$i"
	    _TINITS=$(tinits_pull "$i")
	    for id in $_TINITS; do [ -f __END__$id ] && . __END__$id;done
	    [ -f __END__ ] && . __END__
	done < <(tac $_twtmp.ends 2>/dev/null)
	cd "$d"
	_cd="$d"
    else			# jump elsewhere, ends and inits
	while read i; do
	    cd "$i"
	    _TINITS=$(tinits_pull "$i")
	    for id in $_TINITS; do [ -f __END__$id ] && . __END__$id;done
	    [ -f __END__ ] && . __END__
	done < <(cat $_twtmp.ends 2>/dev/null)
	rm -f $_twtmp.ends
	tscd "$d"
    fi
}

# executes all the tests in current (_cd) dir
ts_dir(){
    local i r ocd="$_cd"
    for i in *; do
	r=$(realpath "$i")
	if [ -d "$i" ]; then
	    if [[ $i =~ [.]subtests$ ]]; then # only go in *.subtests dirs
		ts_chdir "$r"
		ts_dir
	    fi
	else # ignore #_.-prefixed, ~-suffixed, core tewiba and non-executables
	    if [[ $i =~ (^[\#._]|~$|^core$) ]] || \
		[ ! -x "$i" ] || [ "$i" = tewiba ] || [ ! -s "$i" ]; then
		continue
	    else
		ts_test "$r"
	    fi
	fi
    done
}

# will this test be run for the current level?
# $1=test file, returns 0 if OK
# we pre-detect it before running TLEVEL in file, avoiding extra "test ok" mess
ts_level(){
    local tlevel=$(grep -oP '^[[:space:]]*TLEVEL +\K.*' "$1")
    [ -z "$tlevel" ] && return 0 # no TLEVEL line => OK
    [ -z "$TLEVELS" ] || [[ $tlevel =~ [$TLEVELS] ]] || return 1
    return 0
}

# execute a single test in the current directory
ts_test(){
    local t="$1" s="#################################" otvfd="$_tvfd" mess
    local f="${t##*/}"
    ts_level "$t" || return
    ! egrep -q '^([^#]*;|[[:space:]]*)TEND([;[:space:]]|$)' "$t" && \
	$must_tend && \
	! grep -q '^ *#TNOEND' "$t" && [ -s "$t" ] && \
	err "Test file \"$t\" does not have a TEND statement. Use -f to force."
    _TEST_CURRENT="$f" # default TEST name: the filename
    TFAILS=0
    if $_debug; then
	echo "$s$s$nl$s Test File: $t$nl$s$s" >>$_debuglog
        # RUN TEST in Trace Mode
	_tvfd=$twtmp.terr
	bash -x "$t" >>$_debuglog 2>&1; status=$?
	if [ -e $_tvfd ]; then
	    echo "$s Tewiba traces:">>$_debuglog; cat $_tvfd >>$_debuglog 
	    rm -f $_tvfd
	fi
	_tvfd="$otvfd"
    else
	TECHO "== Test file: $f:"
        # RUN TEST
	_tvfd=$twtmp.terr
	"$t" >$_twtmp.out 2> >(tee -a $_twtmp.err >&1); status=$?
	[ -e $_tvfd ] && mess=$(cat $_tvfd)
	rm -f $_tvfd
	_tvfd="$otvfd"
	[ -n "$mess" ] && TECHO "$mess"
	let '_ts_failures += status'
	if [ $status == 0 ]; then
	    if test -s $_twtmp.err; then 
		if $TV; then TECHO "OK, but printed on stderr:"
		else TECHOF "###Warning: test $f OK, but printed on stderr:"
		fi
		print_indent $_twtmp.err
	    else
		TECHO "== OK"
	    fi
	else
	    if $TV; then TECHO "***ERRORS:$status"
	    else 
		TECHOF "***FAILED ($status ERRORS): $f"
		if test -s $_twtmp.err; then print_indent $_twtmp.err; fi
	    fi
	fi
	if $TV && test -s $_twtmp.out; then print_indent $_twtmp.out; fi
	[ -n "$tmp" ] && rm -rf $tmp $tmp.*
    fi
}

# print test outputs indented by 3 spaces for lisibility, on _tvfd
print_indent(){
    [ -n "$_tvfd" ] && \
	sed -e 's/^/   /' <"$1" >>$_tvfd || \
	sed -e 's/^/   /' <"$1" >&2
}

# is $1 a subdir of $2? aka $2 is a strict non-empty substring of $1?
is_subdir_of(){ [ -n "$2" ]&&[ "${1:0:${#2}}" == "$2" ]&&[ "$1" != "$2" ];}

############################################ Main

# run all tests given in arguments, or in the current dir if none given

if [ $# == 0 ]; then
	ts_chdir .
	ts_dir .
else
    for t in "$@"; do
	cd "$TEWIBADIR"		# if t is a relative path
	r=$(realpath "$t")	# use only r from now on, as we may cd
	if [  -d "$r" ]; then 
		ts_chdir "$r"
		ts_dir "$r"
	elif [ -x "$r" ]; then 
	    d="${r%/**}"; f="${r##*/}"
		ts_chdir "$d"
		ts_test "$f"
	elif [ -e "$r" ]; then
	    err "$t is not executable!"
	else err
	    "$t not found!"
	fi
    done
fi
[ -n "$_cd" ] && { ts_chdir; _cd=;}

############################################ Epilogue: print results, and exit
if [ $_ts_failures = 0 ]; then V "All tests OK =="
else echo "== ***** Total tests failed: $_ts_failures *****"
fi
$_debug  && TECHOF "== log of execution in $_debuglog for $*"
[ -n "$statusfile" ] && echo "$_ts_failures" >"$statusfile"
_ts_exit $_ts_failures
