#!/bin/bash
export TEWIBA=1.0
USAGE='tewiba [options] [tests...]
Tewiba: TEst WIth BAsh: a simple test suite, in the spirit of shell scripting
Runs the test suite, on all tests in the current dir (default), 
or on specific tests or directories of tests given as arguments.
   * Tests are given as arguments, and executed in order, they can be either
      * an executable file
      * a directory, all executable files in it will be run as tests
        Filenames beginning with a . # _ or ending with "~" are ignored
        no recursion is done, subdirs will not be explicitely scanned
     if an executable file __INIT__ is found, it will be sourced into the shell
     so that its definitions will be available for all the tests in it
     Same, if an __END__ file is found, it will be sourced after the tests
   * Nothing is printed if all tests OK. On failure, the stderr is printed
   * Tests exit code must be the number of failed tests (0 = OK)
   * A warning is printed if the test was OK but printed on stderr
   * Tests are run in their directory
   * Exit code is the number of failed tests. 
     It is also written in .tewiba.res

How to write tests:
   * Tests are executable files, that exit with code 0 if OK, and the number 
     of failure if not
   * Give tests meaningful names. "Test for empty input" rather than "ei.test"
   * Filenames beginning with a "." "#" "_" or ending with "~" are ignored
     as well as files named "tewiba"
   * They must print on stderr an explanation of the error, or a warning if 
     exit code is 0. Prints on stdout are only shonw in verbose mode
   * Tests can create temporary files and dirs prefixed by "$tmp."
     they will be automatically cleaned afterwards by rm -rf $tmp $tmp.*
   * Test data can be put in subdirectories, as subdirectories are not tested
   * Convenience functions & variables that you can use in tests:
     TEST message  prints (sub)test name if verbose
     TERR message  declares an error, but continues the tests
     ERR  message  declares an error, but aborts the current test file
     TEND          terminates your test script (alias for: exit $TFAILS)
     $TV           is true in verbose mode, false otherwise
     $tmp          temporary data prefix (see above)
     $nl           is the newline character
     $TEWIBA       the version number of tewiba. 
                   Trick: put after #!/bin/bash the line:
                   [ -n "$TEWIBA" ] || exec tewiba -v "$0"
                   so that the test file can be executed standalone
     $TEWIBADIR    the original directory where tewiba was run

Options:
   -v      verbose: prints each test name as it is run, as well as its stdout
   -x      debug: execute each test in set -x more copying also the output to
           /tmp/tewiba.$LOGNAME.out Note: does not imply -v
   -s file outputs the total number of errors in the file. 
           Default is ".tewiba.errors" in current dir

Version '"$TEWIBA"' - Web site: http://colas.nahaboo.net/Software/Tewiba
Copyright (c) 2013-2015 Colas Nahaboo (http://colas.nahaboo.net)
MIT License: http://opensource.org/licenses/MIT
'

export debug=false
export debuglog=/tmp/tewiba.$LOGNAME.out
export statusfile=$PWD/.tewiba.errors
export TEWIBADIR="$PWD" TV

err () { echo "***ERROR: $*" >&2; exit 1; }
warn () { echo "###Warning: $*" >&2; }
V () { :;}; T () { :;}; TV=false; E () { echo "$@";}; En () { echo -n "$@";}
Vn () { :;}
while test "_${1#-}" != "_$1" -a "_${1//-/}" != "_";do case "$1" in
  -v) V () { echo "== $*" >&2;}; Vn () { echo -n "== $*" >&2;}; TV=true
      T () { local i;En "==";for i in $*;do En " $i="`eval E '$'$i`;done;E;};;
  -x) debug=true; rm -f $debuglog;;
  *) echo "$USAGE"; exit 1;
esac;shift; done; if test "_$1" = "_--";then shift; fi

export ts_failures=0
export tmp=/tmp/tewiba.$$
ttmp=/tmp/tewiba-main.$$
export nl=$'\n' #'
export TFAILS=0
export TDIR=
TEST () { $TV && echo "== $*"; }
TERR () { echo "***TEST ERROR ${0##*/}*** $*" >&2; let fails++; }
ERR () { echo "***FATAL ERROR ${0##*/}*** $*" >&2; let fails++; exit $TFAILS; }
TEND () { exit $TFAILS; }
export -f TEST TERR ERR TEND

# cautious cd
err_cd () {
  cd "$1" 2>/dev/null || \
  err "tewiba failed to enter test dir: "$(readlink -m "$1")
}

# executes all the tests that are direct sons of a dir
ts_dir () {
  local i oldpwd="$PWD"
  err_cd "$1" 
  for i in *; do
    [[ $i =~ (^[#._]|~$) ]] || [ ! -x "$i" -o -d "$i" ] ||
      [ "$i" = tewiba ] && continue
    ts_test "$i"
  done
  cd "$oldpwd"
}

# go execute a test in its directory
ts_test_path () {
    local path=$(readlink -m "$1") oldpwd="$PWD"
    err_cd "${path%/*}"
    ts_test "${path##*/}"
    cd "$oldpwd"
}

# on entering a dir, execute __INIT__
ts_init () {
  local tdir=$(/bin/pwd)
  if [ "$tdir" != "$TDIR" ]; then
    ts_end
    [ -x __INIT__ ] && source __INIT__
    TDIR="$tdir"
  fi
}
# on leaving, execute __END__
ts_end () {
  [ -n "$TDIR" ] && [ -x "$TDIR"/__END__ ] && { 
    local TODIR="$PWD"; cd "$TDIR"; source __END__; cd "$TODIR"
  }
}

# execute a single test in the current directory
ts_test () {
  local t="$1" s="#################################"
  ts_init
  TFAILS=0
  if $debug; then
    echo "$s$s$s$nl$s Test: $t$nl$s$s$s" >>$debuglog
    bash -x "$t" 2>>$debuglog; status=$?
  else
     Vn "Test: $t:"
    ./"$t" >$ttmp.out 2>$ttmp.err; status=$?
    let 'ts_failures += status'
    if [ $status = 0 ]; then
      if test -s $ttmp.err; then 
	if $TV; then echo "OK, but printed on stderr:"
	else echo "###Warning: test $t OK, but printed on stderr:"
	fi
	print_indent $ttmp.err
      else
	$TV && echo " OK"
      fi
    else
      if $TV; then echo "***ERRORS:$status"
      else echo "***FAILED ($status ERRORS): $t"
      fi
      if test -s $ttmp.err; then print_indent $ttmp.err; fi
    fi
    if $TV && test -s $ttmp.out; then print_indent $ttmp.out; fi
    rm -rf $tmp $tmp.*
  fi
}

# print test outputs indented by 3 spaces for lisibility
print_indent () { sed -e 's/^/   /' <"$1"; }

####################################################################### Main
# run all tests given in arguments, or in the current dir if none given
if [ $# == 0 ]; then ts_dir .
else
  for t in "$@"; do
    if [  -d "$t" ]; then ts_dir "$t"
    elif [ -x "$t" ]; then 
      if [[ $t =~ / ]]; then ts_test_path "$t"
      else ts_test "$t"
      fi
    else err "$t is not a test!"
    fi
  done
fi
ts_end

# cleanup temp files
rm -rf $ttmp $ttmp.* $tmp $tmp.*

# print global tests results, and exit
if [ $ts_failures = 0 ]; then V "All tests OK =="
else echo "== ***** Total tests failed: $ts_failures *****"
fi
$debug && echo "== log of execution in $debuglog"
[ -n "$statusfile" ] && echo "$ts_failures" >"$statusfile"
exit $ts_failures
